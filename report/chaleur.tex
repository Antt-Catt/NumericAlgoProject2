\begin{document}

\subsection{Fonctions principales}
\label{ssec:fonc_princ}
Grâce à la discrétisation numérique, l'équation de la chaleur peut être ramenée à la résolution d'un système linéaire. 
La matrice représentant l'opérateur Laplacien étant donnéé, il a suffit de créer la fonction permettant de la construire.
Cette fonction possède une compléxité en $\Theta(N²)$, étant donné qu'on parcours toute la matrice.

Ensuite, nous avons mis en place des "situations" où certains points étaient sources de chaleur. Cela à permis de voir comment se comportait l'algorithme dans des cas de figures différents. Nous représenterons ici que quelques cas, les autres peuvent être observés à l'exécution du programme python \emph{chaleur.py}. Ces simulations (disponibles nous ont permis d'observer facilement les résultats aberrant et donc de détecter de potentiels problèmes dans nos algorithmes.



\subsection{Fonctions auxiliaires}
\label{ssec:fonc_aux}
Il a été nécessaire de mettre en place des fonctions permettant de passer un vecteur en matrice et inversement.
En effet, pour pouvoir afficher les \emph{Heat maps} il a fallu utiliser des matrices. Cependant, afin de résoudre l'équation linéaire, l'environnement de taille $N$*$N$ est représenté comme étant un vecteur de taille $N²$.

Il a aussi fallu mettre en place une fonction permettant donc d'afficher les \emph{Heat maps}. Pour cela nous avons utilisé matplotlib.
Le module possédant déjà une option pour afficher des gradients de température, il nous a juste fallu s'approprier le code.


\subsection{Résultats}
\label{ssec:res}



\end{document}
